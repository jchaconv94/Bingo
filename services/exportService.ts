
import * as XLSX from 'xlsx';
import saveAs from 'file-saver';
import html2canvas from 'html2canvas';
import JSZip from 'jszip';
import { jsPDF } from 'jspdf';
import { Participant, BingoCard } from '../types.ts';

// --- Excel Functions ---

export const exportToExcel = (participants: Participant[]) => {
  // Sheet 1: Participants
  const participantsData = participants.map(p => ({
    ID: p.id,
    Nombre: p.name,
    Apellidos: p.surname,
    DNI: p.dni,
    Telefono: p.phone || ''
  }));

  // Sheet 2: Cartones
  // We flatten the 25 numbers (including the 0 center) or just the 24 valid numbers.
  // To keep it simple for re-import logic, we will save all valid numbers sequentially N1..N24.
  // The center (0) is always implicit at index 12 during generation, so we don't need to save it if we just save valid numbers.
  const cardsData: any[] = [];
  participants.forEach(p => {
    p.cards.forEach(c => {
      const row: any = {
        ID_Part: p.id,
        ID_Carton: c.id,
      };
      // Filter out the 0 center to save clean data
      const validNumbers = c.numbers.filter(n => n !== 0);
      validNumbers.forEach((num, idx) => {
        row[`N${idx + 1}`] = num;
      });
      cardsData.push(row);
    });
  });

  const wb = XLSX.utils.book_new();
  const ws1 = XLSX.utils.json_to_sheet(participantsData);
  const ws2 = XLSX.utils.json_to_sheet(cardsData);

  XLSX.utils.book_append_sheet(wb, ws1, "Participantes");
  XLSX.utils.book_append_sheet(wb, ws2, "Cartones");

  const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob([excelBuffer], { type: 'application/octet-stream' });
  saveAs(blob, `bingo_participantes_${new Date().toISOString().slice(0, 10)}.xlsx`);
};

export const parseExcel = async (file: File): Promise<Participant[]> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const data = new Uint8Array(e.target?.result as ArrayBuffer);
        const wb = XLSX.read(data, { type: 'array' });
        
        const wsP = wb.Sheets['Participantes'] || wb.Sheets[wb.SheetNames[0]];
        const wsC = wb.Sheets['Cartones'] || wb.Sheets[wb.SheetNames[1]];

        if (!wsP) throw new Error("No se encontr贸 la hoja 'Participantes'");

        const rawPart = XLSX.utils.sheet_to_json(wsP) as any[];
        const rawCards = wsC ? XLSX.utils.sheet_to_json(wsC) as any[] : [];

        const participantsMap = new Map<string, Participant>();

        // Process Participants
        rawPart.forEach(r => {
          const id = r.ID ? String(r.ID) : `P${Math.random().toString(36).substr(2, 6)}`;
          participantsMap.set(id, {
            id,
            name: r.Nombre ? String(r.Nombre) : 'Sin Nombre',
            surname: r.Apellidos ? String(r.Apellidos) : '',
            dni: r.DNI ? String(r.DNI) : '',
            phone: r.Telefono ? String(r.Telefono) : '',
            cards: []
          });
        });

        // Process Cards
        rawCards.forEach(r => {
          const pId = r.ID_Part ? String(r.ID_Part) : null;
          if (!pId) return;

          const participant = participantsMap.get(pId);
          if (participant) {
            const numbers: number[] = [];
            // Read N1 to N24
            for (let i = 1; i <= 24; i++) {
              const val = parseInt(r[`N${i}`]);
              if (!isNaN(val)) numbers.push(val);
            }
            
            // If we read exactly 24 numbers, we need to reconstruct the 5x5 grid (inserting 0 at index 12)
            // Note: This assumes the Excel numbers were saved in the specific order generated by the app (Row by Row excluding center)
            if (numbers.length === 24) {
               numbers.splice(12, 0, 0); // Insert center placeholder
            }

            // Validation: If length is not 25 after insertion (or if data was malformed), 
            // this might render oddly, but we accept it for now.
            
            participant.cards.push({
              id: r.ID_Carton ? String(r.ID_Carton) : `C${Math.random().toString(36).substr(2, 4)}`,
              numbers: numbers
            });
          }
        });

        resolve(Array.from(participantsMap.values()));
      } catch (err) {
        reject(err);
      }
    };
    reader.onerror = (err) => reject(err);
    reader.readAsArrayBuffer(file);
  });
};

// --- Image & PDF Generation Functions ---

const createTempCardElement = (participant: Participant, card: BingoCard, title: string, subtitle: string = ""): HTMLElement => {
  const container = document.createElement('div');
  
  // Configuraci贸n de estilos generales para alta resoluci贸n
  Object.assign(container.style, {
    width: '800px', // Increased resolution width
    padding: '40px',
    backgroundColor: '#ffffff',
    color: '#1e293b', 
    fontFamily: "'Inter', system-ui, sans-serif",
    position: 'absolute',
    top: '-9999px',
    left: '-9999px',
    boxSizing: 'border-box',
    backgroundImage: 'radial-gradient(circle at top right, #f8fafc 0%, #ffffff 100%)'
  });

  // Header Section
  const header = `
    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 30px; border-bottom: 3px solid #0f172a; padding-bottom: 20px;">
      <div style="flex: 1;">
        <h1 style="font-size: 36px; font-weight: 900; margin: 0; color: #0f172a; letter-spacing: -0.02em; line-height: 1.1; text-transform: uppercase;">${title}</h1>
        ${subtitle ? `<div style="font-size: 18px; color: #64748b; font-weight: 500; margin-top: 8px;">${subtitle}</div>` : ''}
        
        <div style="margin-top: 24px; display: flex; gap: 20px; align-items: center;">
           <div>
              <div style="font-size: 12px; text-transform: uppercase; letter-spacing: 1px; font-weight: 700; color: #94a3b8;">Participante</div>
              <div style="font-size: 24px; font-weight: 700; color: #334155; line-height: 1.2;">${participant.name} ${participant.surname}</div>
           </div>
           <div style="border-left: 2px solid #e2e8f0; padding-left: 20px;">
              <div style="font-size: 12px; text-transform: uppercase; letter-spacing: 1px; font-weight: 700; color: #94a3b8;">DNI</div>
              <div style="font-size: 20px; font-weight: 600; color: #475569;">${participant.dni}</div>
           </div>
        </div>
      </div>
      
      <div style="text-align: right;">
        <div style="background: #0f172a; color: white; padding: 8px 20px; border-radius: 12px; display: inline-block; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);">
            <div style="font-size: 12px; font-weight: 600; opacity: 0.8; text-transform: uppercase; letter-spacing: 2px;">Cart贸n</div>
            <div style="font-size: 42px; font-weight: 800; line-height: 1;">#${card.id.replace(/^C/, '')}</div>
        </div>
        <div style="font-size: 14px; color: #94a3b8; margin-top: 12px; font-weight: 500;">${new Date().toLocaleDateString()}</div>
      </div>
    </div>
  `;

  // Colors for B-I-N-G-O headers
  const bingoColors = [
    { bg: '#3b82f6', text: 'white', l: 'B' }, // Blue
    { bg: '#ef4444', text: 'white', l: 'I' }, // Red
    { bg: '#e2e8f0', text: '#475569', l: 'N' }, // Slate (Center)
    { bg: '#10b981', text: 'white', l: 'G' }, // Emerald
    { bg: '#f59e0b', text: 'white', l: 'O' }  // Amber
  ];

  // Grid Section
  let gridHtml = `
    <table style="width: 100%; border-collapse: separate; border-spacing: 15px;">
       <thead>
        <tr>
          ${bingoColors.map(c => 
            `<th style="text-align: center; padding-bottom: 10px;">
                <div style="
                  width: 90px; 
                  height: 90px; 
                  background-color: ${c.bg}; 
                  color: ${c.text};
                  border-radius: 50%; 
                  display: flex; 
                  align-items: center; 
                  justify-content: center; 
                  font-size: 48px; 
                  font-weight: 900; 
                  margin: 0 auto;
                  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                  text-shadow: ${c.text === 'white' ? '0 2px 4px rgba(0,0,0,0.2)' : 'none'};
                ">
                  ${c.l}
                </div>
            </th>`
          ).join('')}
        </tr>
      </thead>
      <tbody>
  `;

  for(let r=0; r<5; r++) {
    gridHtml += '<tr>';
    for(let c=0; c<5; c++) {
      const index = r * 5 + c;
      const value = card.numbers[index];
      const isCenter = index === 12;

      // Modern Cell Style: White card-like cells instead of black blocks
      const cellStyle = `
        width: 20%;
        height: 90px;
        background-color: ${isCenter ? '#f1f5f9' : '#ffffff'}; 
        border: ${isCenter ? '3px solid #cbd5e1' : '2px solid #e2e8f0'};
        border-radius: 16px;
        text-align: center;
        vertical-align: middle;
        font-size: 42px;
        font-weight: 800;
        color: ${isCenter ? '#cbd5e1' : '#1e293b'};
        padding: 0;
        margin: 0;
        line-height: 1;
        box-shadow: ${isCenter ? 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)' : '0 4px 6px -1px rgba(0, 0, 0, 0.05)'};
      `;

      const contentWrapper = `display:flex; justify-content:center; align-items:center; height:100%; width: 100%;`;

      if (isCenter) {
        gridHtml += `
          <td style="${cellStyle}">
             <div style="${contentWrapper}; flex-direction: column; gap: 4px;">
                <svg width="40" height="40" viewBox="0 0 24 24" fill="#94a3b8" stroke="none" xmlns="http://www.w3.org/2000/svg">
                   <path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/>
                </svg>
                <span style="font-size: 12px; font-weight: 900; text-transform: uppercase; letter-spacing: 1px; color: #94a3b8;">Libre</span>
             </div>
          </td>`;
      } else {
        gridHtml += `<td style="${cellStyle}"><div style="${contentWrapper}">${value}</div></td>`;
      }
    }
    gridHtml += '</tr>';
  }

  gridHtml += `</tbody></table>`;

  const footer = `
    <div style="margin-top: 40px; border-top: 1px solid #e2e8f0; padding-top: 20px; display: flex; justify-content: space-between; align-items: center;">
      <div style="font-size: 14px; color: #64748b; font-weight: 600;">
        隆Mucha Suerte! 
      </div>
      <div style="text-align: right;">
         <div style="font-size: 14px; font-weight: 700; color: #0f172a;">Sistema de Bingo Virtual</div>
         <div style="font-size: 12px; color: #94a3b8; margin-top: 2px;">Generado autom谩ticamente</div>
      </div>
    </div>
  `;

  container.innerHTML = header + gridHtml + footer;
  return container;
};

export const downloadCardImage = async (participant: Participant, card: BingoCard, title: string = "BINGO VIRTUAL", subtitle: string = "") => {
  const el = createTempCardElement(participant, card, title, subtitle);
  document.body.appendChild(el);
  try {
    const canvas = await html2canvas(el, { scale: 2, useCORS: true, backgroundColor: '#ffffff' });
    const blob = await new Promise<Blob | null>(resolve => canvas.toBlob(resolve, 'image/png'));
    if (blob) {
      saveAs(blob, `bingo_${participant.name.replace(/\s+/g,'_')}_${card.id}.png`);
    }
  } finally {
    document.body.removeChild(el);
  }
};

export const downloadAllCardsZip = async (participants: Participant[], title: string = "BINGO VIRTUAL", subtitle: string = "") => {
  const zip = new JSZip();
  const folder = zip.folder("cartones_bingo");
  
  for (const p of participants) {
    for (const card of p.cards) {
      const el = createTempCardElement(p, card, title, subtitle);
      document.body.appendChild(el);
      try {
        const canvas = await html2canvas(el, { scale: 1.5, backgroundColor: '#ffffff' });
        const dataUrl = canvas.toDataURL('image/png');
        const base64 = dataUrl.split(',')[1];
        folder?.file(`${p.name.replace(/\s+/g,'_')}_${card.id}.png`, base64, { base64: true });
      } finally {
        document.body.removeChild(el);
      }
    }
  }

  const content = await zip.generateAsync({ type: "blob" });
  saveAs(content, "todos_cartones.zip");
};

export const generateBingoCardsPDF = async (participant: Participant, title: string, subtitle: string = "", specificCardId?: string) => {
  // Initialize PDF in A4 Portrait (mm)
  const doc = new jsPDF({
    orientation: 'portrait',
    unit: 'mm',
    format: 'a4'
  });

  // A4 Dimensions: 210mm x 297mm
  const pageWidth = 210;
  const pageHeight = 297;
  const margin = 10;
  const gap = 10;
  
  // Grid Calculations (2 columns, 2 rows)
  const cardWidth = (pageWidth - (margin * 2) - gap) / 2; // approx 90mm
  const cardHeight = (pageHeight - (margin * 2) - gap) / 2; // approx 133.5mm

  // Positions for 4 cards
  const positions = [
    { x: margin, y: margin },                                   // Top-Left
    { x: margin + cardWidth + gap, y: margin },                 // Top-Right
    { x: margin, y: margin + cardHeight + gap },                // Bottom-Left
    { x: margin + cardWidth + gap, y: margin + cardHeight + gap } // Bottom-Right
  ];

  const cardsToProcess = specificCardId 
    ? participant.cards.filter(c => c.id === specificCardId)
    : participant.cards;

  if (cardsToProcess.length === 0) return;

  for (let i = 0; i < cardsToProcess.length; i++) {
    const card = cardsToProcess[i];
    const posIndex = i % 4;

    // Add new page if we filled the previous 4 slots
    if (i > 0 && posIndex === 0) {
      doc.addPage();
    }

    // Render card to image
    const el = createTempCardElement(participant, card, title, subtitle);
    document.body.appendChild(el);
    
    try {
      // Use reasonable scale for PDF quality
      const canvas = await html2canvas(el, { scale: 2, backgroundColor: '#ffffff' });
      const imgData = canvas.toDataURL('image/jpeg', 0.9); // slightly compressed JPEG for smaller PDF size

      let pos = positions[posIndex];
      
      // If generating a single specific card, center it on the page for better presentation
      if (specificCardId && cardsToProcess.length === 1) {
        pos = {
            x: (pageWidth - cardWidth) / 2,
            y: (pageHeight - cardHeight) / 2
        };
      }
      
      // Calculate aspect ratio to fit within the grid cell
      const imgProps = doc.getImageProperties(imgData);
      const pdfRatio = cardWidth / cardHeight;
      const imgRatio = imgProps.width / imgProps.height;

      let w = cardWidth;
      let h = cardHeight;

      // Fit contain logic
      if (imgRatio > pdfRatio) {
        h = w / imgRatio;
      } else {
        w = h * imgRatio;
      }
      
      // Center in cell (or page if overridden above)
      const xCentered = pos.x + (cardWidth - w) / 2;
      const yCentered = pos.y + (cardHeight - h) / 2;

      doc.addImage(imgData, 'JPEG', xCentered, yCentered, w, h);
      
      // Optional: Add a light border around the card area for cutting reference
      doc.setDrawColor(200, 200, 200);
      doc.rect(xCentered, yCentered, w, h);

    } finally {
      document.body.removeChild(el);
    }
  }

  // Save the PDF
  let fileName = `Cartones_Bingo_${participant.name.replace(/\s+/g, '_')}.pdf`;
  if (specificCardId) {
      fileName = `Bingo_${participant.name.replace(/\s+/g, '_')}_${specificCardId}.pdf`;
  }
  doc.save(fileName);
  
  return fileName;
};
